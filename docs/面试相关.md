# 面试相关

[TOC]



## 项目介绍

### 为什么做这样一个项目

在学习完数据库连接池、线程池后，需要做一个项目将这些基础模块都用起来，因此想到做一个TinyWebserver'的项目。同时这个项目也是网络编程、并发编程的一个较为基础的项目

### 介绍一下你的项目

Linux下C++轻量级Web服务器

使用线程池+基于RAII的数据库连接池+非阻塞socklet+eppoll（ET和LT均实现）+事件处理（Reactor和Proactor均实现）的并发模型

使用**状态机**解析HTTP请求报文，支持GET和POST

访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件；

实现**同步/异步**日志系统，记录服务器运行状态；

经Webbench压力测试可以实现上万的并发连接数据交换；

## 线程池相关

### 手写线程池

熟悉掌握`threadpool.h`的内容

### 线程的同步机制有那些

信号量、条件变量、互斥信号量

### 线程池中的工作线程是一直等待的吗？

是的，等待新任务的唤醒

### 你的线程池工作线程处理完一个任务后的状态是什么？

如果请求队列为空，则该线程进入线程池中等待；若不为空，则该线程跟其他线程一起进行任务的竞争

### **如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢**？

该项目是基于IO复用的并发模式。当客户连接有事件需要处理的时，epoll会进行事件提醒，而后讲对应的任务加入请求队列，等待工作线程竞争执行。如果同时有1000个客户端进行访问、线程数不够时，可以在初始化线程池时增加初始化的线程数量（初始时的线程数多，后续根据任务队列中任务数量动态调整）。

### 如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?

会，因为线程的数量是固定的，如果一个客户请求长时间占用着线程资源，势必会影响到服务器对外的整体响应速度。解决的策略可以是给每一个线程处理任务设定一个时间阈值，当某一个客户请求时间过长，则将其置于任务请求最后，或断开连接。

## 并发模型相关

### 简单说一下你的服务器使用的并发模型

[参考博客](https://blog.csdn.net/zhizhengguan/article/details/112171898)

服务器主要有两种并发编程模式：半同步/半异步 、领导者/追随者 模式。

- 同步指的是程序完全按照代码序列的顺序执行
- 异步指的是程序的执行需要由系统事件驱动

半同步/半异步模式工作流程

> - 同步线程处理客户逻辑
> - 异步线程处理IO事件
> - 异步线程监听到客户请求后，将其封装成对象并插入到请求队列中
> - 请求队列通知某个工作在同步模式的工作线程来读取并处理该请求对象

本服务器选择的是半同步/半异步的变种即**半同步半反应堆**的并发模型。分别实现了reactor模式和proactor

- reactor模式中，主线程(**I/O处理单元**)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(**逻辑单元** )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由**同步I/O**实现。
- proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由**异步I/O**实现。

### reactor、proactor、主从reactor模型的区别？

主从reactor模型

### 你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？

比较常用的有三种：select/poll/epoll。本项目之所以采用epoll，参考问题（[why sis epoll faster than select](https://stackoverflow.com/questions/17355593/why-is-epoll-faster-than-select))

## HTTP报文解析

### 用了状态机啊，为什么要用状态机？

有限状态机，是一种抽象的理论模型，它能够把有限个变量描述的状态变化过程，以可构造可验证的方式呈现出来。比如，封闭的有向图。有限状态机可以通过if-else,switch-case和函数指针来实现，主要是为了封装逻辑。在解析http报文的过程中存在不同的状态, 我们在解析的时候根据解析的内容判断不同状态下不同的处理方法,通过状态的转换,实现对协议的解析

### 状态机的转移图画一下？

![img](https://mmbiz.qpic.cn/mmbiz_jpg/6OkibcrXVmBH2ZO50WrURwTiaNKTH7tCia3AR4WeKu2EEzSgKibXzG4oa4WaPfGutwBqCJtemia3rc5V1wupvOLFjzQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

主状态机，三种状态，标识解析位置

- CHECK_STATE_REQUESTLINE，解析请求行
- CHECK_STATE_HEADER，解析请求头
- CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求

从状态机，三种状态，标识解析一行的读取状态

- LINE_OK，完整读取一行
- LINE_BAD，报文语法有误
- LINE_OPEN，读取的行不完整

### https协议为什么安全，画出连接过程

待完成

### GET和POST的区别

[推荐参考](https://www.cnblogs.com/logsharing/p/8448446.html)



## 数据库登录注册相关

### 登录说一下？

- 载入数据库表，结合代码将数据库中的数据载入到服务器中；
- 提取用户名和密码，结合代码对报文进行解析，提取用户名和密码；
- 注册登录流程，结合代码对描述服务器进行注册和登录校验的流程；
- 页面跳转，结合代码对页面跳转机制进行详解

### 你这个保存状态了吗？如果要保存，你会怎么做？

**没有保存**，但是可以利用session或者cookie的方式进行状态的保存。（后续可以看看如何实现使用cookie和session保存状态）

### 登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？

优化方法一：

> 对于大数据最遍历的方法就是**进行hash，利用hash建立多级索引的方式来加快用户验证**。首先，将10亿的用户信息，利用大致缩小1000倍的hash算法进行hash，这时就获得了100万的hash数据，每一个hash数据代表着一个**用户信息块（一级）**；
>
> 而后，再分别对这100万的hash数据再进行hash，例如最终剩下1000个**hash数据（二级）**。
>
> 在这种方式下，服务器只需要保存1000个二级hash数据，当用户请求登录的时候，先对用户信息进行一次hash，找到对应信息块（二级），在读取其对应的一级信息块，最终找到对应的用户数据，

优化方法二：

>待完成

### Redis了解过吗？用过吗？

## 定时器相关

### 为什么要用定时器

—处理定时任务，或者非活跃连接，节省系统资源；

### **说一下定时器的工作原理**？

服务器就为各事件分配一个定时器。该项目使用SIGALRM信号来实现定时器，首先每一个定时事件都处于一个升序链表上，**通过alarm()函数周期性触发SIGALRM信号**，而后信号回调函数利用管道通知主循环，主循环接收到信号之后对升序链表上的定时器进行处理：若一定时间内无数据交换则关闭连接。

### 双向链表啊，删除和添加的时间复杂度说一下？还可以怎么优化？

添加一般情况下都是O(N)，删除只需要O(1)。从双向链表的方式优化不太现实，可以考虑使用最小堆、或者跳表的数据结构

## 日志相关

### 说下你的日志系统的运行机制？

初始化服务器时，利用**单例模式**初始化日志系统，根据配置文件确认是同步还是异步写入的方式。

### 为什么要异步？和同步的区别是什么？

同步方式写入日志时会产生比较多的系统调用，若是某条日志信息过大，会阻塞日志系统，造成系统瓶颈。异步方式采用生产者-消费者模型，具有较高的并发能力。

### 现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？

待完成

## 压测相关

### 并发量测试过吗？怎么测试的？

测试过，利用webbench，至少满足万余的并发量。